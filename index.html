<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Text to Speech Converter</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <!-- MP3 Encoding Library -->
    <script src="https://cdn.jsdelivr.net/npm/lamejs@1.2.1/lame.min.js"></script>
    <style>
        body {
            font-family: 'Inter', sans-serif;
        }
        .loader {
            border: 4px solid #f3f3f3;
            border-top: 4px solid #3498db;
            border-radius: 50%;
            width: 40px;
            height: 40px;
            animation: spin 1s linear infinite;
        }
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        .btn-disabled {
             opacity: 0.5;
             cursor: not-allowed;
        }
    </style>
</head>
<body class="bg-gray-100 dark:bg-gray-900 text-gray-900 dark:text-gray-100 flex items-center justify-center min-h-screen">
    <div class="container mx-auto p-4 md:p-8 max-w-2xl">
        <div class="bg-white dark:bg-gray-800 rounded-lg shadow-lg p-6 md:p-8">
            <h1 class="text-3xl font-bold mb-4 text-center text-gray-800 dark:text-white">Text-to-Speech Converter</h1>
            <p class="text-center text-gray-600 dark:text-gray-300 mb-6">Your long text is split into paragraphs. Audio will be generated one paragraph at a time and play sequentially.</p>

            <div class="mb-4">
                <label for="voice-select" class="block mb-2 text-sm font-medium text-gray-700 dark:text-gray-300">Choose a voice:</label>
                <select id="voice-select" class="bg-gray-50 border border-gray-300 text-gray-900 text-sm rounded-lg focus:ring-blue-500 focus:border-blue-500 block w-full p-2.5 dark:bg-gray-700 dark:border-gray-600 dark:placeholder-gray-400 dark:text-white">
                    <option value="Kore">Kore (Firm)</option>
                    <option value="Puck">Puck (Upbeat)</option>
                    <option value="Zephyr">Zephyr (Bright)</option>
                    <option value="Charon">Charon (Informative)</option>
                    <option value="Fenrir">Fenrir (Excitable)</option>
                    <option value="Leda">Leda (Youthful)</option>
                    <option value="Orus">Orus (Firm)</option>
                    <option value="Aoede">Aoede (Breezy)</option>
                    <option value="Sadachbia">Sadachbia (Lively)</option>
                    <option value="Sulafat">Sulafat (Warm)</option>
                </select>
            </div>

            <textarea id="text-input" rows="12" class="w-full p-4 border border-gray-300 rounded-lg bg-gray-50 dark:bg-gray-700 dark:border-gray-600 dark:text-white focus:ring-blue-500 focus:border-blue-500" placeholder="Enter Text Here"> </textarea>

            <div id="button-container" class="flex space-x-2 mt-6">
                <button id="generate-btn" class="w-full bg-blue-600 hover:bg-blue-700 text-white font-bold py-3 px-4 rounded-lg transition duration-300">
                    Generate and Play
                </button>
                 <button id="download-btn" class="w-full bg-green-600 hover:bg-green-700 text-white font-bold py-3 px-4 rounded-lg transition duration-300 hidden">
                    Download All as MP3
                </button>
            </div>

             <div id="playback-controls" class="mt-6 items-center justify-between hidden">
                <div class="w-full bg-gray-200 dark:bg-gray-700 rounded-full h-2.5 mb-4">
                    <div id="progress-bar" class="bg-blue-600 h-2.5 rounded-full" style="width: 0%"></div>
                </div>
                 <p id="current-text-display" class="text-sm text-gray-600 dark:text-gray-400 p-4 bg-gray-50 dark:bg-gray-700 rounded-lg h-24 overflow-y-auto"></p>
                <div class="flex items-center justify-center mt-4 space-x-4">
                    <button id="previous-btn" class="bg-gray-300 hover:bg-gray-400 text-gray-800 font-bold py-2 px-4 rounded-lg">Previous</button>
                     <button id="play-pause-btn" class="bg-blue-600 hover:bg-blue-700 text-white font-bold py-2 px-6 rounded-lg">Play</button>
                    <button id="next-btn" class="bg-gray-300 hover:bg-gray-400 text-gray-800 font-bold py-2 px-4 rounded-lg">Next</button>
                </div>
            </div>

            <div id="loading-indicator" class="mt-6 flex-col items-center justify-center hidden">
                <div class="loader mb-2"></div>
                <p id="loading-text">Generating audio, please wait...</p>
            </div>

            <div id="error-message" class="mt-4 text-red-500 text-center hidden"></div>

            <audio id="audio-player" class="w-full mt-6 hidden"></audio>
        </div>
        <footer class="text-center mt-4 text-sm text-gray-500 dark:text-gray-400">
            <p>Powered by Google Gemini</p>
        </footer>
    </div>

    <script>
        // DOM Elements
        const generateBtn = document.getElementById('generate-btn');
        const downloadBtn = document.getElementById('download-btn');
        const buttonContainer = document.getElementById('button-container');
        const textInput = document.getElementById('text-input');
        const voiceSelect = document.getElementById('voice-select');
        const audioPlayer = document.getElementById('audio-player');
        const loadingIndicator = document.getElementById('loading-indicator');
        const loadingText = document.getElementById('loading-text');
        const errorMessage = document.getElementById('error-message');
        const playbackControls = document.getElementById('playback-controls');
        const playPauseBtn = document.getElementById('play-pause-btn');
        const nextBtn = document.getElementById('next-btn');
        const previousBtn = document.getElementById('previous-btn');
        const currentTextDisplay = document.getElementById('current-text-display');
        const progressBar = document.getElementById('progress-bar');

        // State
        let textChunks = [];
        let currentChunkIndex = 0;
        let audioCache = {};

        function resetUI() {
            playbackControls.classList.add('hidden');
            buttonContainer.innerHTML = '';
            buttonContainer.appendChild(generateBtn);
            buttonContainer.appendChild(downloadBtn);
            generateBtn.textContent = 'Generate and Play';
            downloadBtn.classList.add('hidden');
            downloadBtn.classList.remove('btn-disabled');
            downloadBtn.disabled = false;
        }

        // --- Audio Processing and API Helpers ---
        function base64ToArrayBuffer(base64) {
            const binaryString = window.atob(base64);
            const len = binaryString.length;
            const bytes = new Uint8Array(len);
            for (let i = 0; i < len; i++) {
                bytes[i] = binaryString.charCodeAt(i);
            }
            return bytes.buffer;
        }

        async function getAudioForChunk(index) {
            const voice = voiceSelect.value;
            const cacheKey = `${voice}-${index}`;
            if (audioCache[cacheKey]) return audioCache[cacheKey];

            showLoading(true, `Generating paragraph ${index + 1} of ${textChunks.length}...`);
            const text = textChunks[index];
            if (!text) {
                showError(`Paragraph ${index + 1} is empty.`);
                return null;
            }

            const apiKey = "";
            const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-tts:generateContent?key=${apiKey}`;
            const payload = {
                contents: [{ parts: [{ text }] }],
                generationConfig: {
                    responseModalities: ["AUDIO"],
                    speechConfig: { voiceConfig: { prebuiltVoiceConfig: { voiceName: voice } } }
                },
                model: "gemini-2.5-flash-preview-tts"
            };

            try {
                let response;
                for (let i = 0; i < 5; i++) {
                    try {
                        response = await fetch(apiUrl, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(payload) });
                        if (response.ok) break;
                    } catch (e) { /* ignore network errors for retry */ }
                    await new Promise(res => setTimeout(res, Math.pow(2, i) * 1000));
                }

                if (!response || !response.ok) throw new Error(`API failed after retries with status: ${response?.status}`);

                const result = await response.json();
                const part = result?.candidates?.[0]?.content?.parts?.[0];
                const audioData = part?.inlineData?.data;
                const mimeType = part?.inlineData?.mimeType;

                if (audioData && mimeType?.startsWith("audio/")) {
                    const rateMatch = mimeType.match(/rate=(\d+)/);
                    const sampleRate = rateMatch ? parseInt(rateMatch[1], 10) : 24000;
                    const pcmDataBuffer = base64ToArrayBuffer(audioData);
                    const pcm16Data = new Int16Array(pcmDataBuffer);
                    const cacheItem = { pcmData: pcm16Data, sampleRate: sampleRate };
                    audioCache[cacheKey] = cacheItem;
                    return cacheItem;
                } else {
                    throw new Error("Invalid audio data in API response.");
                }
            } catch (error) {
                console.error('API Error:', error);
                showError(`Failed to generate audio for paragraph ${index + 1}. Error: ${error.message}`);
                return null;
            } finally {
                showLoading(false);
            }
        }

        // --- MP3 Download Logic (DEFINITIVE FIX) ---
        function encodeMp3Async(pcmData, sampleRate) {
            return new Promise((resolve, reject) => {
                try {
                    const mp3Encoder = new lamejs.Mp3Encoder(1, sampleRate, 128);
                    const sampleBlockSize = 1152;
                    let mp3Data = [];
                    let currentOffset = 0;

                    function encodeNextChunk() {
                        if (currentOffset >= pcmData.length) {
                            const finalMp3buf = mp3Encoder.flush();
                            if (finalMp3buf.length > 0) mp3Data.push(new Int8Array(finalMp3buf));
                            resolve(new Blob(mp3Data, { type: 'audio/mp3' }));
                            return;
                        }
                        const progress = Math.round((currentOffset / pcmData.length) * 100);
                        showLoading(true, `Encoding to MP3... ${progress}% complete`);
                        const sampleChunk = pcmData.subarray(currentOffset, currentOffset + sampleBlockSize);
                        const mp3buf = mp3Encoder.encodeBuffer(sampleChunk);
                        if (mp3buf.length > 0) mp3Data.push(new Int8Array(mp3buf));
                        currentOffset += sampleBlockSize;
                        setTimeout(encodeNextChunk, 0);
                    }
                    encodeNextChunk();
                } catch (err) {
                    reject(err);
                }
            });
        }

        async function downloadAllAsMP3() {
            downloadBtn.classList.add('btn-disabled');
            downloadBtn.disabled = true;
            showError(null);

            try {
                let allPcmData = [];
                let totalLength = 0;
                let finalSampleRate = 24000;

                for (let i = 0; i < textChunks.length; i++) {
                    const chunkData = await getAudioForChunk(i);
                    if (chunkData) {
                        if (i === 0) finalSampleRate = chunkData.sampleRate;
                        allPcmData.push(chunkData.pcmData);
                        totalLength += chunkData.pcmData.length;
                    }
                }

                if (allPcmData.length === 0) throw new Error("No audio data available to download.");

                showLoading(true, "Combining audio tracks...");
                const combinedPcm = new Int16Array(totalLength);
                let offset = 0;
                allPcmData.forEach(pcm => {
                    combinedPcm.set(pcm, offset);
                    offset += pcm.length;
                });

                const mp3Blob = await encodeMp3Async(combinedPcm, finalSampleRate);
                showLoading(false);

                const downloadUrl = URL.createObjectURL(mp3Blob);
                const finalLink = document.createElement('a');
                finalLink.href = downloadUrl;
                finalLink.download = 'audio_output.mp3';
                finalLink.textContent = 'Save MP3 File';
                finalLink.className = 'w-full bg-green-700 hover:bg-green-800 text-white font-bold py-3 px-4 rounded-lg transition duration-300 text-center';

                const startOverBtn = document.createElement('button');
                startOverBtn.textContent = 'Start Over';
                startOverBtn.className = 'w-full bg-gray-500 hover:bg-gray-600 text-white font-bold py-3 px-4 rounded-lg transition duration-300';
                startOverBtn.onclick = () => {
                    resetUI();
                    URL.revokeObjectURL(downloadUrl);
                };
                
                buttonContainer.innerHTML = '';
                buttonContainer.appendChild(finalLink);
                buttonContainer.appendChild(startOverBtn);

            } catch (error) {
                console.error("Download failed:", error);
                showError(`Could not create MP3. Error: ${error.message}`);
                showLoading(false);
                downloadBtn.classList.remove('btn-disabled');
                downloadBtn.disabled = false;
            }
        }

        // --- Playback Logic ---
        async function playChunk(index) {
            currentChunkIndex = index;
            const audioInfo = await getAudioForChunk(index);
            if (audioInfo) {
                const wavBlob = pcmToWav(audioInfo.pcmData, audioInfo.sampleRate);
                const wavUrl = URL.createObjectURL(wavBlob);
                audioPlayer.src = wavUrl;
                audioPlayer.play().catch(e => console.error("Playback error:", e));
                playPauseBtn.textContent = 'Pause';
                updateUIForChunk(index);
            } else {
                playPauseBtn.textContent = 'Play';
            }
        }

        function startPlayback() {
            const fullText = textInput.value.trim();
            if (!fullText) {
                showError("Please enter some text.");
                return;
            }
            textChunks = fullText.split('\n').filter(t => t.trim().length > 0);
            if (textChunks.length === 0) {
                showError("No text paragraphs found to play.");
                return;
            }
            resetUI();
            currentChunkIndex = 0;
            audioCache = {};
            showError(null);
            playbackControls.classList.remove('hidden');
            playbackControls.classList.add('flex', 'flex-col');
            downloadBtn.classList.remove('hidden');
            generateBtn.textContent = "Restart Playback";
            playChunk(0);
        }

        function pcmToWav(pcmData, sampleRate) {
            const buffer = new ArrayBuffer(44 + pcmData.length * 2);
            const view = new DataView(buffer);
            writeString(view, 0, 'RIFF');
            view.setUint32(4, 36 + pcmData.length * 2, true);
            writeString(view, 8, 'WAVE');
            writeString(view, 12, 'fmt ');
            view.setUint32(16, 16, true);
            view.setUint16(20, 1, true);
            view.setUint16(22, 1, true); // Mono
            view.setUint32(24, sampleRate, true);
            view.setUint32(28, sampleRate * 2, true);
            view.setUint16(32, 2, true);
            view.setUint16(34, 16, true);
            writeString(view, 36, 'data');
            view.setUint32(40, pcmData.length * 2, true);
            for (let i = 0; i < pcmData.length; i++) {
                view.setInt16(44 + i * 2, pcmData[i], true);
            }
            return new Blob([view], { type: 'audio/wav' });
        }

        function writeString(view, offset, string) {
            for (let i = 0; i < string.length; i++) view.setUint8(offset + i, string.charCodeAt(i));
        }

        // --- UI and Event Handlers ---
        function updateUIForChunk(index) {
            currentTextDisplay.textContent = textChunks[index];
            progressBar.style.width = `${((index + 1) / textChunks.length) * 100}%`;
            previousBtn.disabled = index === 0;
            previousBtn.classList.toggle('btn-disabled', index === 0);
            nextBtn.disabled = index === textChunks.length - 1;
            nextBtn.classList.toggle('btn-disabled', index === textChunks.length - 1);
        }

        function handlePlayPause() {
            if (audioPlayer.paused && audioPlayer.src) {
                audioPlayer.play();
                playPauseBtn.textContent = 'Pause';
            } else {
                audioPlayer.pause();
                playPauseBtn.textContent = 'Play';
            }
        }

        audioPlayer.addEventListener('ended', () => {
            if (currentChunkIndex < textChunks.length - 1) playChunk(currentChunkIndex + 1);
            else playPauseBtn.textContent = 'Play';
        });

        function showLoading(isLoading, message = "Generating audio, please wait...") {
            loadingText.textContent = message;
            loadingIndicator.style.display = isLoading ? 'flex' : 'none';
        }

        function showError(message) {
            errorMessage.style.display = message ? 'block' : 'none';
            errorMessage.textContent = message;
        }

        // Event Listeners
        generateBtn.addEventListener('click', startPlayback);
        downloadBtn.addEventListener('click', downloadAllAsMP3);
        playPauseBtn.addEventListener('click', handlePlayPause);
        nextBtn.addEventListener('click', () => { if (currentChunkIndex < textChunks.length - 1) playChunk(currentChunkIndex + 1); });
        previousBtn.addEventListener('click', () => { if (currentChunkIndex > 0) playChunk(currentChunkIndex - 1); });

    </script>
</body>
</html>

